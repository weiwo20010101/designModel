## 设计模式 

### 创建型设计模式

### 代码

[github链接](https://github.com/weiwo20010101/designModel)

### `简单工厂模式`

#### 定义

简单工厂模式有一个具体的工厂类，在产品种类相对较小的情况下，考虑使用简单工厂模式可以很方便的创建所需产品。

#### 角色

简单工厂 抽象产品 具体产品

#### **简单工厂模式在框架源码中的应用**

- 在 `Logback`源码中的应用

  ```java
  public class JDKCalendar {
    
      private static final Logger log= LoggerFactory.getLogger(JDKCalendar.class);
  
  }
  
      public static Logger getLogger(Class<?> clazz) {
          return new Logger(clazz.getName());
      }
  
  
      public Logger(String name) {
          impl = java.util.logging.Logger.getLogger(name);
      }
  
  ```

#### **简单工厂模式的优点**

结构简单，调用方便，对于外界给定的信息，我们能够很方便的创建出对应的产品。

#### **简单工厂模式的缺点**

工厂类单一，当产品技术过多，工厂类代码十方臃肿，考虑进一步的划分。

### `工厂方法模式`

#### 介绍

指定义一个创建对象的接口，但是由实现这个接口的类来决定实例化哪个类，工厂方法把类的实例化推迟到子类中进行。

当增加一个产品时，只需增加一个相应的工厂类的子类，实现生成这种产品，便可解决简单工厂生产太多产品导致其内部代码臃肿的问题，符合开闭原则（增加类，而不是修改之前的代码）。

#### 角色

- 抽象工厂

- 具体工厂

- 抽象产品

- 具体产品

#### **使用工厂方法模式实现产品拓展**

工厂方法模式主要解决产品拓展的问题，在简单工厂中，随着产品链的丰富，如果每个课程的创建逻辑都有区别，则工厂的职责会变得越来越多，有点像万能工厂，不符合单一职责原则，不利于维护，于是我们继续拆分，专人干专事，Java课程由Java工厂创建，Python课程由Python工厂创建，对工厂本身也做抽。

#### **在`Logback`源码中的应用**

#### **缺点**

类的个数过多，增加复杂度

抽象产品只能生产一种产品

增加了系统的抽象性和理解难度

### `抽象工厂模式`

#### **介绍**

抽象工厂模式指提供一个创建一系列相关或者相互依赖对象的接口，无需指定他们具体的类。

在抽象工厂模式中，客户端强调一系列相关的产品对象（同一个产品族）一起创建，需要大量重复的代码。

需要一个提供产品类的库，所有产品以同样的接口出现，一种产品一个接口，抽象工厂返回的是所有的抽象接口。

抽象工厂也可以使用`abstract`+`extends`的方式具体化。

#### **概念**

产品族  一家工厂提供的所有产品  假设 m种

产品等级结构   不同工厂提供的同一种产品   假设 n种

产品    由产品族和产品等级结构划分   m*n种  需要大量重复的代码

### `单例模式`

#### **定义**

确保一个类在任何情况下都绝对都只有一个实例，并且提供一个全局访问点，属于创建型设计模式。

#### **应用场景**

- 对于一些频繁创建的类，减少内存压力，减少GC
- 某些类创建实例时占用资源较多，或者实例化耗时较长，且经常使用
- 频繁访问数据库和文件的对象

#### **实现方式**

通过隐藏构造方法，在内部实例化一次，并且提供一个全局的访问点。

#### **使用单例模式解决实际问题**

#####     饿汉式 单例写法的弊端

饿汉式单例模式的标准写法

```java
public class Client {
    public static void main(String[] args) {
        Singleton instance = Singleton.getInstance();

    }

    static class Singleton{
        private static  final  Singleton instance=new Singleton();
        private Singleton(){};
        public static Singleton getInstance(){
            return instance;
        }
    }
}
```

饿汉式单例写法在类的加载的时候立即进行初始化，并且创建单例对象。在线程还没出现之前就实例化了，不可能存在访问安全问题。

饿汉式的另外一种写法，使用静态块的机制。

```java
public class Client2 {

    static  class HungryStaticsSingleton{
        private static final  HungryStaticsSingleton hungrySingleton;
        static {
            hungrySingleton=new HungryStaticsSingleton();
        }
        private  HungryStaticsSingleton(){};
        public  static  HungryStaticsSingleton getInstance(){
            return hungrySingleton;
        }
    }
}
```

饿汉式单例写法适用于单例对象较少的情况。这样写可以保证绝对的线程安全（在类加载的时候就进行初始化，并且创建单例对象）,但是缺点也比较明显，就是所有对象累在类加载的时候就实例化。这样一来，如果系统中有大批量的单例对象存在，那么初始化时会造成大量的内存浪费，从而导致系统内存不可控。也就是说，不管对象用或者不用，都占着空间，浪费了内存，有可能占着内存又不使用，那么这个时候有没有更优的写法呢？

##### 懒汉式写法

在使用的时候才会初始化

```java
public class Client3 {
     
    static  class  Singleton{
        private Singleton(){};
        
        private static Singleton instance=null;
        public static  Singleton getInstance(){
          if(instance==null){
              instance=new Singleton();
          }
          return instance;
        }
    }
}

```

但是这样写又带来了一个新的问题，如果在多线程环境下，则会出现线程安全问题，存在线程安全隐患。

这里我简单的使用同步方法解决，加锁对性能有一定的影响。

```
public class Client4 {

    static  class  Singleton{
        private Singleton(){};
        private  static  Singleton singleton=null;

        public  static synchronized  Singleton getInstance(){
            if(singleton==null){
                singleton=new Singleton();
            }
            return singleton;
        }
    }
}
```

### `原型模式`

#### 定义

不是通过`new`关键字而是通过对象复制来实现创建对象的模式被称为原型模式。

原型模式 指原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象，属于创建型设计模式。

原型模式的核心在于复制原型对象。以系统中已经存在的一个对象为原型，直接基于内存二进制流进行复制，不需要再经历耗时的对象初始化过程（不调用构造函数），性能提升很多。

这为我们创建对象另辟蹊径，当对象的构建过程比较耗时的时候，我们可以躲避初始化过程，使得新对象的创建时间大大缩短。

#### 应用场景

1. 创建对象成本较大 （例如：初始化时间长渣，占用CPU多，占用网络资源太多）
2. 创建一个对象需要繁琐的数据准备和访问权限等等，需要提高性能和提高安全性。
3. 该对象在系统中大量使用，并且各个调用者都需要给它的属性重新赋值。

#### 角色

1. 客户`client` ：客户提出创建对象的请求
2. 抽象原型 `IPrototype`：规定复制接口
3. 具体原型 `ConcretePrototype`：被复制的对象

#### 使用原型模式解决实际问题

在Java提供的API中，不需要手动创建抽象原型接口，因为Java已经内置了`Cloneable` 抽象原型接口，自定义的类型只需要实现该接口并且重写`Object.clone()`即可完成本类的复制。

实现该接口唯一的意思是告知Java虚拟机可以安全的在本类中使用clone()方法，而如果没有实现该接口，调用clone()就会抛出 `CloneNotSupportedException`异常。

复制的结果有如下性质：

1.  `o.clone() != o`
2.  ` o.clone().getClass() =  o.getClass()`
3.  `o.clone().equals(o)`  如果对象o的`equals()`方法定义正确

```java
public class Client2 {


    public static void main(String[] args) {
        Prototype prototype=new Prototype("origin");
        Prototype clone = prototype.clone();
        System.out.println(clone.toString());
    }
    static class Prototype implements Cloneable{
        private  String desc;

        public Prototype(String desc){
            this.desc=desc;
        }
        @Override
        public Prototype clone(){
            Prototype prototype=null;
            try{
                prototype=(Prototype) super.clone();
            } catch (CloneNotSupportedException e) {
                e.printStackTrace();
            }
            return prototype;
        }

        @Override
        public String toString(){
            return this.getClass().getSimpleName() +".desc= "+desc;
        }
    }
}
```

`super.clone()`方法直接从堆内存中以二进制流的方式进行复制，重新分配一个内存块，因此效率很高滴。

也就是说该方法基于内存复制，不会调用对象的构造方法，也就是Java字节码层面的` <init>`方法，不需要经历初始化过程。

#### 存在的问题

##### 问题1

在日常开发中，使用`super.clone()`方法并不能满足所有需求，如果类中存在引用对象属性，那么原型对象与克隆对象的该属性会指向同一对象的应用。例如属性`List<String> strs`,这显然不是我们想要的结果，那么如何解决呢？

序列化

##### 解决方法

使用序列化实现深克隆

我对输入输出流的了解有限，现在了解一下`ByteArrayOutputStream`,`ObjectOutputStream`...........


对象操作流 `ObjectOutputStream` `ObjectInputStream`

```java
 
public class Demo1_ObjectOutputStream {
 
	public static void main(String[] args) throws IOException{
		Student s1=new Student("张三",23);
		Student s2=new Student("李四",24);
		ObjectOutputStream os=new ObjectOutputStream(new FileOutputStream("record.txt"));
		os.writeObject(s1);
		os.writeObject(s2);
		os.close();

	} 
}

public class Demo2_ObjectInputStream {
 
	public static void main(String[] args) throws IOException, ClassNotFoundException {
		ObjectInputStream ois=new ObjectInputStream(new FileInputStream("record.txt"));
		Student s1=(Student) ois.readObject();
		Student s2=(Student) ois.readObject();
		System.out.println(s1);
		System.out.println(s2);
		ois.close();
 
	}
 
}


public class Demo3 {
 
	public static void main(String[] args) throws IOException, ClassNotFoundException {
		ArrayList<Student> list1=new ArrayList<Student>();
		list1.add(new Student("张三",23));
		list1.add(new Student("李四",24));
		list1.add(new Student("王五",25));
		list1.add(new Student("赵六",26));
		ObjectOutputStream os=new ObjectOutputStream(new FileOutputStream("record.txt"));
		os.writeObject(list1);
		System.out.println("集合对象写入到文件成功！");
		os.close();
		ObjectInputStream osi=new ObjectInputStream(new FileInputStream("record.txt"));
		ArrayList<Student> list2=(ArrayList<Student>) osi.readObject();
		osi.close();
		System.out.println("从磁盘读取到的集合遍历结果");
		for (Student student : list2) {
			System.out.println(student);
		}
	}
}
```

深复制的实现

```java
public class Client3{


    static class Prototype implements Cloneable{
        private  String desc;

        public Prototype(String desc){
            this.desc=desc;
        }

        @Override
        public Prototype clone(){
            Prototype prototype=null;
            try{
                prototype=(Prototype) super.clone();
            } catch (CloneNotSupportedException e) {
                e.printStackTrace();
            }
            return prototype;
        }

        @Override
        public String toString(){
            return this.getClass().getSimpleName() +".desc= "+desc;
        }

        public Prototype deepClone(){
            try {
                ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
                ObjectOutputStream objectOutputStream=new ObjectOutputStream(outputStream);
                objectOutputStream.writeObject(this);

                ObjectInputStream objectInputStream=new ObjectInputStream(new ByteArrayInputStream(outputStream.toByteArray()));
                Object o = objectInputStream.readObject();
                return (Prototype) o;
            }catch (IOException | ClassNotFoundException e){
                e.printStackTrace();
                return  null;
            }
        }
    }
}
```

##### 问题2

破坏了克隆怎么办？

##### 解决方法

- 单例类不实现 `cloneable` 接口，自然就不可以克隆了，不然会抛出异常

- 重写clone()方法，返回单例对象即可。

  ```java
  @Override
  pubilc Prototype clone(){
      return instance;
  }
  ```

#### 原型模式的优点

- 基于内存二进制流的方式，在性能上比直接new更加的优良。
- 深克隆的方式可以做到完全复制，有助于保存对象的状态，简化创建对象的过程，也可以用来还原到某一个历史状态，可辅助实现撤销操作。

#### 原型模式的缺点

- 需要为类配置一个`clone()`方法

- `clone()`位于类的内部，对方法改造的话，不符合开闭原则。

- 实现深克隆的话，需要进行序列化和反序列化，操作很复杂

### `建造者模式`

属于创建型设计模式，将一个复杂对象的构建过程与表示分离，实现构建与表示分离，使得同样的构建行为根据不同的过程来创建不同的表示，其中构建的行为顺序有时候也会导致不同的表示。

#### 应用场景 

创建简单而又多类的对象，使用工厂模式，而如果是创建一个复杂的对象，就可以考虑使用建造者模式。

需求：

相同的方法，不同的执行顺序，产生不同的结果。

多个部件或零件，都可以装配到一个对象中，但是产生的结果不同。

初始化一个复杂对象的很多参数都具有默认值。

#### 角色

1. 产品

2. 抽象建造者：建造者的抽象类，规范产品对象的各个组成部分的创建，一般由子类实现具体的创建过程。

3. 建造者 ：具体的`Builder`类，根据不同的业务逻辑，具体化对象的各个组成部分的创建

4. 调用者：调用具体的建造者来创建对象的各个组成部分，在指导者中不涉及具体产品的信息，只负责保证对象个部分完整创建或者按照某个顺序创建。

   

#### 拓展

建造者模式的优点

1. 封装好，构建和表示分离
2. 拓展性好，构建类之间独立，在一定程度上解耦。
3. 便于控制细节，建造者可以对创建过程逐步细化，而不对其他模块产生影响

建造者模式的缺点

1. 多创建一个`builder`

2. 如果产品内部发生变化，建造者也要发生变化，后期维护困难。

### 结构型模式

### `代理模式`

代理模式是指为其他对象提供一种代理，以控制对这个对象的访问，数据结构型设计模式。

代理对象可以在客户端与目标对象之间起到中介的作用。

#### 应用场景

当无法或者不想直接引用某个对象或者访问某个对象存在困难的时候，可以通过代理对象来间接访问，使用代理模式主要有两个目的，一是保护目标对象，二是增强目标对象。

#### 角色

抽象主题角色：声明真实主题与代理的共同接口方法，该类可以是接口，也可以是抽象类。

真实主题角色：

代理主题角色：也被称为代理类，其内部持有真实主题角色的应用，具备对真实主题角色的完全代理权。

客户端调用代理对象的方法，也调用被代理对象的方法，代码增强体现在在原代码逻辑前后增加一些代码逻辑，而使得调用者无感知。

#### 分类

静态代理

动态代理

#### 使用代理模式解决实际问题

比如从静态代理到动态代理。

从一对父母帮自己孩子说媒到开办婚介所。

#### Java动态代理

```java
public class Client2 {
    public static void main(String[] args) {
        JdkMeipo meipo=new JdkMeipo();
        IPerson instance = meipo.getInstance(new ZhaoLiu());
        instance.findLove();
    }
    interface IPerson{
        void findLove();
    }

    static class  JdkMeipo implements InvocationHandler{

        private IPerson target;
        public IPerson getInstance(IPerson target){
            this.target=target;
            Class<? extends IPerson> clazz = target.getClass();
            return (IPerson) Proxy.newProxyInstance(clazz.getClassLoader(),clazz.getInterfaces(),this);
        }
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            String name=method.getName();
            Object result=null;
            before();
            if(name.equals("findLove")){

                 result= method.invoke(this.target,args);
                 System.out.println("是这个");
            }
            after();
            return  result;
        }
        public void before(){
            System.out.println("媒婆收到需求，开始物色");
        }
        public void after(){
            System.out.println("多才多亿 开始交往");
        }
    }
    static class ZhaoLiu implements IPerson{
        @Override
        public void findLove(){
            System.out.println("符合老刘的要求");
        }
        public void buyInsure(){

        }
    }
}
```

![image-20210906010459872](https://gitee.com/weiwo20010101/image/raw/master/image-20210906010459872.png)

#### 结合源码分析

暂无

#### 总结

静态代理违背开闭原则，如果被代理类增加了新的方法，则代理类需要同步增加

动态代理具有可拓展性，符合开闭原则。

动态代理可配合策略模式使用，新增策略类即可完成拓展，无需修改代理类的代码。

#### 优点

将代理对象与真实对象分离

降低耦合性，拓展性好

保护或增强目标对象

#### 缺点

类数量，处理请求速度 ，系统复杂度。

### `门面模式`

又叫外观模式，提供了一个统一的接口，用来访问子系统中的一群接口，其主要特征是定义了一个高层接口，让子系统更容易调用，属于结构型设计模式。

#### 使用门面模式整合已知API

比如某个社区上线了一个积分兑换礼品的商城，这个商城中的大部分功能都不是重新开发的，而是要去对象已有的各个子系统。

如果所有的接口调用全部去由前端发送网络请求去调用一直接口，一会增加前端开发人员的难度，二会增加一些网络请求，影响网络性能，此时就可以发挥门面模式的优势了。将所有线程的接口全部整合到一个类中，由后端提供统一的接口供前端调用，这样前端开发人员就可以不需要关心各个接口的业务关系，只需要把经历集中到页面交互上去。

#### 源码应用

- Spring JDBC 模块下的JdbcUtils类，他们封装了与JDBC有关的所有操作。

#### 总结

门面模式的优点

- 方便调用
- 不用深入了解子系统，以防给子系统带来风险
- 符合设计原则中的最少知道原则，和具体实现解耦，提高了安全性。

门面模式的缺点

- 一定程度上违背单一职责原则

- 不符合开闭原则，因为当子系统修改了，那么门面的调用也要跟着改。

  

### `装饰器模式`

装饰器模式也叫做包装模式，是指在不改变原有对象的基础上动态给一个对象增加一些额外的职责,比起生成子类实现更为灵活。

提起装饰，我们先来想一下生活中有哪些装饰：

提到装饰，我们先来想一下生活中有哪些装饰：

女生的首饰：戒指、耳环、项链等装饰品
家居装饰品：粘钩、镜子、壁画、盆栽等等
我们为什么需要这些装饰品呢？我们很容易想到是为了美，戒指、耳环、项链、壁画、盆栽都是为了提高颜值或增加美观度。但粘钩、镜子不一样，它们是为了方便我们挂东西、洗漱。所以我们可以总结出装饰品共有两种功能：

- 增强原有的特性：我们本身就是有一定颜值的，添加装饰品提高了我们的颜值。同样地，房屋本身就有一定的美观度，家居装饰提高了房屋的美观度。
- 添加新的特性：在墙上挂上粘钩，让墙壁有了挂东西的功能。在洗漱台装上镜子，让洗漱台有了照镜子的功能。

并且我们发现，装饰品并不会改变物品本身，只是起到一个锦上添花的作用。装饰模式也一样，它的主要作用就是：

- 增强一个类原有的功能
- 为一个类添加新的功能

并且装饰模式也不会改变原有的类。

模板  请画出UML图

```java
public class Client {

   static abstract class Component{
         abstract  void operation();
    }
    static  abstract  class Decorator extends Component{

        private Component component;
        public Decorator(Component component){
            this.component=component;
        }

        public void operation(){
           component.operation();
        }
    }
    static class ConcreteDecoratorA extends Decorator{
       public ConcreteDecoratorA(Component component){
           super(component);
       }
       public void after(){
           System.out.println("after");
       }
        public void before(){
            System.out.println("before");
        }

        @Override
        public void operation() {
            before();
            super.operation();
            after();
        }
    }
    static class ConcreteDecoratorB extends Decorator{
        public ConcreteDecoratorB(Component component){
            super(component);
        }
        public void after(){
            System.out.println("after");
        }
        public void before(){
            System.out.println("before");
        }

        @Override
        public void operation() {
            before();
            super.operation();
            after();
        }
    }
     static class ConcreteComponent extends Component{


         @Override
         void operation() {
             System.out.println("playing");
         }
     }
    public static void main(String[] args) {
        ConcreteComponent component=new ConcreteComponent();
        ConcreteDecoratorA concreteDecoratorA = new ConcreteDecoratorA(component);
        concreteDecoratorA.operation();

    }

}

```

学会使用装饰器模式解决`加码`问题。比如给煎饼多加一块肉，还是煎饼，但是价格和数量都会有所变化

![image-20210906181344758](https://gitee.com/weiwo20010101/image/raw/master/image-20210906181344758.png)

具体代码见`github`

#### 特征

实现接口的类型就是装饰器中属性元素的类型

```java
public class TransactionAwareCacheDecoretor implements Cache{
    private final Cache targetCache;8
    public TransactionAwareCacheDecoretor(Cache targetCache){
        this.targetCache=targetCache;
    }
}
```

具体装饰器继承抽象装饰器（一般是抽象类），实现抽象方法，共用父类属性，而父类属性是被装饰对象和抽象装饰器的共同接口，构造方法调用父类构造方法，同样的方法名，内部其实对父类方法进行一定修改。

抽象装饰器保存对共同接口的应用。

#### 区别

装饰器模式强调自身功能的拓展.`Decorator`所做的就是增强`Concrete Component`的功能，主体对象为`Concrete Component`,着重类功能的变化。

代理模式强调对代理过程的控制。`Proxy`完全掌握对`RealSubject`的访问控制，因此，`Proxy`可以决定对`RealSubject`进行功能拓展，功能缩减，主体对象是`Proxy`

拿租房来讲，必然有一些事务发生：比如房源搜索，联系房东谈价格。

- 中介去做

- 增加自己相关的能力，自己去做。

### `享元模式`

面向对象的技术可以很好的解决一些灵活性或者可拓展性问题，但在很多情况下需要在系统中增加类和对象的个数。当对象数量太多，将导致运行代价过高，带来性能下降问题。享元模式正式为了解决这一问题而诞生的。

其实就是缓存的思想。

#### 实现方式举例

- 使用hashmap实现缓存，有就获取，没有再创建

- 池化技术
- String类型

```
public class StringTest {
    public static void main(String[] args) {
   String s1="hello";
   String s2="he"+"llo";
   String s3=new String("hello");
   String s5="he"+new String("llo");
   String s6=s5.intern();
   String s7=s3.intern();
   String s8="h";
   String s9="ello";
   String s10=s8+s9;
        System.out.println(s1==s2);
        System.out.println(s1==s3);
        System.out.println(s1==s5);
        System.out.println(s1==s6);
        System.out.println(s1==s7);
        System.out.println(s1==s10);
        System.out.println(s5==s6);
        System.out.println(s6==s7);
        
        System.out.println(s6==s2);

    }
}

```

对这些比较的理解涉及到JVM的概念，我正好学过一遍，还是不难的：

String类型被定义为由final修饰的，是不可变的，JVM中字符串一般都被保存在字符串常量池，Java会确保一个字符串在常量池中只有一个"复制"，在JDK7之前，字符串常量池是放在方法区（也叫永久代）的常量池中的，之后被放置到堆中（因为我们在开发中需要创建大量并且一次性的字符串，需要较高的垃圾回收频率，而在永久代比起堆空间，垃圾回收是很少的）。

对于`new String("")`之类的方法，实际上是创建了一个对象在堆空间中，而不是一个到字符创常量池的引用，当然不是一个引用。并且对于字符串来说,`==`这种比较方式比较的是地址，而不是值，这也是我们分析所在区域的前提。

- 特殊的，`s5.intern()`这个方法是使得一个位于堆中的字符串在运行期间动态的加入字符串常量池，如果池中已经有了该对象对应的字面量，就返回引用，否则就复制一份字面量到字符串常量池中并且返回引用。
- 特殊的，对于s2的写法，JVM在编译期间是自动优化的，拼接起来。

Integer和Long类型的缓存:  -128~127

#### 享元模式的优点

减少对象创建降低内存

#### 享元模式的缺点

比较关注内，外部状态，内部是指共享出来的信息，外部随环境而改变，不可共享。

逻辑更复杂。

### `组合模式`

组合模式用于整体与部分的关系，当整体与部分有相似的接口，在操作的时候可以被一致地对待的时，就可以使用组合模式。

例如：树形菜单，公司组织架构和操作系统目录，文件夹和子文件夹的关系，文件夹中可以存放文件，也可以新建文件夹，子文件夹也一样，总公司和子公司的关系，公司可以设立部门，也可以设立分公司，分公司同理，树枝和分树枝的关系，树枝可以长出叶子，也可以长出树枝，分树枝也一样。

```java
public class Client {

     static abstract class Component {
        // 职位
        private String position;
        // 工作内容
        private String job;

        public Component(String position, String job) {
            this.position = position;
            this.job = job;
        }

        // 做自己的本职工作
        public void work() {
            System.out.println("我是" + position + "，我正在" + job);
        }

        abstract void addComponent(Component component);

        abstract void removeComponent(Component component);

        abstract void check();
    }
   static class Manager extends Component {
        // 管理的组件
        private List<Component> components = new ArrayList<>();

        public Manager(String position, String job) {
            super(position, job);
        }

        @Override
        public void addComponent(Component component) {
            components.add(component);
        }

        @Override
        void removeComponent(Component component) {
            components.remove(component);
        }

        // 检查下属
        @Override
        public void check() {
            work();
            for (Component component : components) {
                component.check();
            }
        }
    }
    static class Employee extends Component {

        public Employee(String position, String job) {
            super(position, job);
        }

        @Override
        void addComponent(Component component) {
            System.out.println("职员没有管理权限");
        }

        @Override
        void removeComponent(Component component) {
            System.out.println("职员没有管理权限");
        }

        @Override
        void check() {
            work();
        }
    }
}
```

使用组合模式之后，我们解决了之前的两个弊端。

将共有的字段和方法移到了父类中，消除了重复，并且在客户端中，可以一致地对待`Manager`和`Employee`类，因为统一申明为`Component`对象，统一调用`Component`对象的`addComponent`方法添加子对象即可。

#### 透明方式

我们应该注意到，`Employee`类虽然继承了父类的`addComponent`和`removeComponent`方法，但是仅仅提供了一个空实现罢了，因为`Employee`类是不支持添加和移除组件的。这样是否违背了接口隔离原则呢?

>接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。

答案是肯定的，这样却是违背了接口隔离原则。这种方式在组合模式中被称为透明方式。

这种方式有它的优点：让 Manager 类和 Employee 类具备完全一致的行为接口，调用者可以一致对待它们。

但它的缺点也显而易见：Employee 类并不支持管理子对象，不仅违背了接口隔离原则，而且客户端可以用 Employee 类调用 addComponent 和 removeComponent 方法，导致程序出错，所以这种方式是不安全的。

#### 安全方式

那么我们可不可以将 addComponent 和 removeComponent 方法移到 Manager 子类中去单独实现，让 Employee 不再实现这两个方法呢？我们来尝试一下。

```java
public class Client2 {

    static abstract class Component{
        private String position;
        private String job;
        public Component(String position,String job){
            this.job=job;
            this.position=position;
        }
        public void work(){
            System.out.println("我是"+position+"我正在"+job);
        }
        abstract  void check();
    }
    static class Manager extends Component{
        private List<Component> list =new ArrayList<>();

        public Manager(String position, String job) {
            super(position, job);
        }

        @Override
        public void work() {
          super.work();
        }

        @Override
        void check() {
             work();
             for(Component component:list){
                 component.check();
             }
        }
        public void addComponent(Component component){
            list.add(component);
        }
        public void removeComponent(Component component){
            list.remove(component);
        }

    }
    static class Employee extends Component{
        public Employee(String position, String job) {
            super(position, job);
        }

        @Override
        public void work() {
            super.work();
        }

        @Override
        void check() {
       work();
        }
    }

    public static void main(String[] args) {
      Employee employee=new Employee("c","d");
      Manager manager=new Manager("a","b");
      manager.addComponent(employee);
      manager.check();
    }
}
```

安全方式符合接口隔离原则，上层接口或者抽象类选择交集。

同样的，由于将两个类区别对待，两个类具有不同的接口，带来了使用上的不变。

#### 组合模式

一般是使用透明方法，虽然优点不安全，但是客户端不需要去区分叶子节点和枝节点，用起来真香。

问：组合模式中的安全方式与透明方式有什么区别？

答案：声明内容是节点方法的  交集 还是 并集

透明方式：在 Component 中声明**所有**管理子对象的方法，包括 add 、remove 等，这样继承自 Component 的子类都具备了 add、remove 方法。对于外界来说叶节点和枝节点是透明的，它们具备完全一致的接口。

安全方式：在 Component 中不声明 add 和 remove 等管理子对象的方法，这样叶节点就无需实现它，只需在枝节点中实现管理子对象的方法即可。

### 

### `适配器模式`

适配器模式又叫做变压器模式，它的功能是将一个类的接口变成客户端所期望的另一种接口，从而使得原本因接口不匹配而到导致无法在一起工作的两个类能够一起工作，属于结构型设计模式。

在软件开发中，基本上一切问题都可以通过增加一个中间层来解决。适配器模式其实就是一个中间层。综上，适配器模式起着转化/委托的作用，将一种接口转化为另一种接口符合需求的接口。

#### 应用场景

在生活中，适配器模式有着非常多的应用场景，例如，电源差转换头，手机充电转换头，显示器转接头。

#### 角色

目标角色 ：我们所期望的接口

原角色 ：指内容满足客户需求但是接口不匹配的接口实例。

适配器 : 将原角色转化为目标角色，转化为我们所期望的接口

#### 类适配器

通过继承原角色和实现目标角色接口来实现适配器功能

#### 对象适配器

通过组合来实现适配器功能。

在适配器内部持有原角色对象，可以调用原角色方法，实现目标接口，在实现的方法中完成适配。

#### 接口适配器

之前的两种适配器关注的是将系统中存在的一个角色转化成目标角色所需的内容，通过继承，实现，持有（组合）等等方法实现适配器，而接口适配器的应用场景是当接口的方法过多的时候，如果直接实现接口，那么类中就会多出许多空实现的方法，显的很臃肿。此外，使用接口适配器就能只实现我们需要的接口方法，使得目标更加的清晰。

#### 适配器模式和装饰器模式的区别

都是包装类模式，装饰器模式其实是一种特殊的代理模式。

装饰器有层级关系，抽象装饰器和被装饰着实现同一个对象或者继承同一个抽象类，然后抽象装饰器中持有接口对象或者父类对象，然后具体装饰器继承抽象装饰器，而适配器模式没有层级关系。

装饰器应该先考虑，先设计架构。而适配器是后考虑，出现了接口不匹配的问题采取解决。

功能上，装饰器注重拓展和覆盖，而适配器注重兼容和转换。

#### 适配器模式的优点

可以多创建几个适配器，而不是修改原有适配器，符合开闭原则

适配器持有原角色对象或者 在类适配器中继承原角色，使得目标和原角色解耦，提高程序的拓展性。

#### 适配器模式的缺点

复杂性和难度，降低可读性。

### `桥接模式`

桥接模式又叫桥梁模式，接口模式或者柄体模式，指将抽象部分与具体实现部分分离，使得他们都可以独立的变化，数据结构型设计模式。

#### 适用场景

- 在抽象和具体实现之间需要增加更多灵活性的场景。

- 一个类存在多个变化的维度，各维度独立拓展,解耦这些变化的维度，使得高层架构稳定

- 不希望使用继承，因为多层继承或导致父类对子类的强侵入，同时会导致子类臃肿，同时由于多了很多子类，会导致系统类的个数剧增。

#### 角色

抽象首先以抽象类的形式存在，持有对所有实现类实现的接口作为属性，因此可以使用构造方法的形式来创建，依赖于实现，抽象类拓展的方式是继承，这种子类叫做修正抽象，具有父类的属性（接口），构造方法和抽象类一致，可以对抽象方法进行重写，来修正和拓展。实现类实现一个共同的接口。客户端调用的时候，将具体实现类作为抽象的构造参数来创建。

再比如一个加急邮件消息，短信是一个接口的实现类，承载内容，其他实现可能是短信，电话，qq等等，加急是抽象类的一种实现,调用方式如下：

```java
message=new EmailMessage();
abstractMessage message=new UrgencyMessage(message);
message.sendMessage(xxxx);
```

我们使用桥接模式解耦了“消息类型”和"消息紧急程度"这两个独立变化的维度，符合开闭原则。

### 行为型设计模式

### `委派模式`

委派模式又叫委托模式，是一种面向对象的设计模式。允许对象组合实现与继承相同的代码重用。它的基本功能就是负责任务的调用和分配，是一种特殊的静态代理模式，但是代理模式注重过程，委派模式注重结果，委派模式属于行为型设计模式。

#### 应用场景

老板 产品经理 员工

### 角色

- 抽象任务角色，定义一个抽象接口，用来约束所有真正执行任务的角色

- 委派者角色，复杂在各个具体角色实例之间做出决策，判断并且调用具体实现类的方法

- 具体任务角色，真正执行任务的角色。

对于真正顶层创建任务的老板来说，产品经理和员工都需要执行任务，只不过产品经理的任务就是分配任务，因此，他们都需要被一个接口所约束，老板将任务分给产品经理，也就是调用产品经理，产品经理将任务分配员工，实现了老板和员工的解耦。

模板代码看我的github对应项目

我代码的示例中是随机调用，也可以是用一个哈希表来实现任务的分配。

比如：

```java
public class Boss{
    public void command(String task,Leader leader){
        leader.doing(task);
    }
    
}
public class Leader implements IEmployee{
    private Map<String ,IEmplyee> map=new HashMap<>();
    public Leader(){
        map.put("爬虫",new EmployeeA());
        map.put("海报",new EmployeeB());
    }
    public void doing(String task){
        if(!employee.containsKey(task))){
           sout("超出能力范围");
}else{
            map.get(task).doing(task);
        }
    }
}
```



#### 委派模式的优点

通过任务委派能够将一个大型任务细化，然后通过统一管理这些子任务的完成情况来实现任务的跟进，加快任务执行的效率。

#### 委派模式的缺点

任务复杂的时候需要进行多重委派，容易紊乱。

### `模板方法模式`

模板方法模式又叫做模板模式即定义一个操作中的算法，而将一些步骤延迟到子类中，使得子类不改变一个算法的结构就可以重复定义该算法的某些特殊步骤。

就是继承

#### 角色

抽象模板

具体实现

注意：

- 可以把抽象模板类的模板方法定义成final类型，避免子类对其进行覆写。



>final的使用
>
>1. final修饰的方法不能被重写，可以用在设计模式当中。将方法定义为final类型可以防止任何子类修改该类的定义与实现方式
>2. 在Java中，所有的private*方法*默认是final的，即不*可继承*的，如果一个方法被定义为private了，就不用在定义为final类型了。
>3. 被final修饰的类不能被继承
>4. 被定义为final的对象只能指向唯一一个对象，不可以改变引用，但是一个对象的值却是可以改变的，将常量声明为static final就是使得一个常量真正不可改变。
>5. final成员变量必须在声明的时候初始化，或者在构造器中初始化
>6. final变量不可再次赋值
>7. final方法在编译阶段绑定，称为静态绑定
>8. final常量名一般大写

### `策略模式`

将定义的算法家族分别封装起来，让他们之间可以互相替换，从而让算法的变化不会影响到使用算法的用户。

使用组合+隔离的方式，就是说一个专门和客户端交互的类持有具体策略角色的接口，让客户端不直接调用策略角色对象，而不是完全和上下文角色交互沟通，因此上下文角色职责就是隔离客户端和策略类的耦合。

#### 应用

多种可切换的选择，每一种选择都能独立的解决问题。

#### 区别

和委派模式比较一下

1. 调用方式，老板和产品经理一个人沟通，不需要知道员工就可以，而策略模式需要我们在上下文环境中选择一种支付方式，我们对支付方式是已知的，对上下文环境也是已知的，调用时候相当于创建一个具体支付方式，由于上下文环境持有抽象支付方式，我们就在上下文环境中调用上下文环境的方法。
2. 作用，通过任务委派能够将一个大型任务细化，然后通过统一管理这些子任务的完成情况来实现任务的跟进，加快任务执行的效率，后者强调用一种有多种选择的场景，需要能够自由切换，每一种选择都能独立解决问题，比如支付方式。

#### 策略模式的优点

1. 符合开闭原则
2. 避免使用多重条件转移语句 if else
3. 提高算法的保密性安全性

#### 缺点

1. 客户端必须知道所有的策略，并且自行决定使用哪一个策略类。
2. 多种策略类，增加维护难度

### `责任链模式`

将链表中的每一个节点都看做一个对象，每个节点内部自动维护下一个节点对象，当一个请求从链式的手段发出时，会沿着责任链预设的路径依次传递到每一个节点对象，直至被链中的某个对象处理为止，属于行为型模式。

#### 应用场景

- 闯关模式，各部门审批。

- 多个对象可以处理同一个请求，但具体由哪个对象处理则是在运行时动态决定。

- 在不明确指定接收者的情况下，向多个对象中的一个提交请求。

- 可动态指定一组对象处理请求。



#### 角色

抽象处理者，定义一个请求处理的方法，并且维护一个下一处理节点的Handler对象的引用。

具体处理者，对请求进行处理，如果不感兴趣，则进行转发。

调用者，在客户端和具体处理者之间加一个中间件，用于将定义好的具体处理者根据业务需求串联起来，形成一条链。

#### 示例

责任链模式和建造者模式结合使用

比如我们登录的时候将校验逻辑都写在一个类中，现在我们可以使用责任链模式来优化代码质量，首先定义一个抽象处理者handler抽象类然后具体的校验逻辑类继承抽象类，实现自己的校验逻辑，然后由调用者串联成一条链,完成登录方法。

比如这样：

```java
public class MemberService{
  public void login(String loginName,String loginPass){
         Handler validateHandler=new ValidateHandler();
    Handler loginHandler=new LoginHandler();
    Handler authHandler =new AuthHandler();
    
    validateHandler.setNext(loginHandler);
    loginHandler.setNext(authHandler);
    
    validateHandler.doHandle(new Member(loginName,loginPass));
  }
}
```

出现的问题：当链式结构较长的时候，上述类的代码会相对臃肿，很复杂，于是我们使用建造者模式进行优化。

```java
//原来的抽象处理者
  public abstract class Handler{
      protected Handler chain;
      private void next(Handler handler){
          this.chain=handler;
      }
     public abstract doHandle(Member member);
  } 
```

```java
//建造者模式优化后的抽象处理者
public abstract  class Handler<T>{
    protected Handler chain;
    public void next(Handler handler){
        this.chain=handler;
       
}
    public abstract void doHandle(Member member);
    
    static class Builder<T> {
      private Handler<T> head;
        private Handler<T> tail;
        public Builder<T> addHandler(Handler<T> handler){
            if(this.tail==null){
                this.head=this.tail=handler;
                return this;
}
          this.tail.next(handler);
          this.tail=handler;
        }
        public Builder<T> build(){
            return this.head;
        }
    }
}


//优化后的调用者
public class MemberService{
    public void login(String loginName,String loginPass){
        Handler.Builder builder =new Handler.Builder();
builder.addHander(new ValidateHandler())
    .addHandler(new LoginHandler())
    .addHandler(new AuthHandler)
    
    builder.build().doHandle(new Member(loginName,loginPass));
    }
}

//客户端操作
main{
    MemberService service=new MemberService();
    service.login("")
}
```



### `迭代器模式`

一般不常用，就不写了。

因为使用迭代器模式不需要了解内部细节，但是我们需要了解一些数据结果的使用的。



### `命令模式`

命令模式解耦了请求方和接收方，请求方只需要请求执行命令，不用关心命令怎么被接收，怎么样被操作或者怎样被执行等等。命令模式属于行为型设计模式，这让我联想到了消息队列，消息的发送方也不需要g关心消息的消费和接收，一致性的实现?分布式系统崩溃？，这时候我们一般选择使用消息队列。

本来在软件系统中，行为请求者与行为实现这通常是一种紧耦合的关系，因为这样的实现简单明了，但是紧耦合关系缺乏拓展性。什么意思呢？就是在某些场合中，当需要对行为进行记录，撤销或者重做等等处理时，只能修改源码，而命令模式通过在请求与实现之间引入一个抽象命令接口，解耦了请求与实现，并且中间件是抽象的，它由不同的子类实现，因此具备拓展性。

#### 角色

- 接收者角色：该类负责具实施或者执行一个请求。

- 抽象命令角色：定义需要执行的所有命令行为。

- 具体命令角色,每个具体命令和接收者耦合，内部持有一个接收者对象

- 请求者角色，接受客户端的命令，持有抽象命令角色

客户端调用方式：

```java
//优化之后
        ConcreteCommandA a=new ConcreteCommandA(new Receiver1());
        Invoker invoker=new Invoker(a);
        invoker.invoke();

```



#### 优点

1. 解耦

2. 稳定性

   Invoker处于业务逻辑区域，比较稳定，接收者处于业务功能区域，比较不稳定，让比较稳定的invoker和比较不稳定的receiver紧耦合，就会导致整个结构都不稳定，这就是引入Icommand的原因，不仅仅是解耦请求与实现，同时也是稳定性的要求。

3. 拓展性

   - 可以将receiver进行抽象，然后使用装饰器模式，（装饰器模式7个类，最上层的方法是所有类共有的，通过接口，继承等等共有），而桥接模式包含6个类(没有最上层接口或者抽象类约束，抽象持有实现的抽象，修正抽象继承抽象类，具体实现继承（当实现是抽象类）或实现（当实现是接口）实现类。

   - receiver是底层细节，可以通过更换不同的receiver达到不同的细节实现。

#### 实战一下

```java
public class Client2 {

    interface   ICommand{
        void cmd();
    }
    static  class Receiver {
        public void add(){
            System.out.println("add");
    }
       public void speed(){
           System.out.println("speed");}
        public void stop(){
            System.out.println("stop");
        }
        public void pause(){
            System.out.println("pause");
        }
    }
    static class addCommand implements  ICommand{
        Receiver receiver=new Receiver();
        @Override
        public void cmd(){
            receiver.add();
        }
    }
    static class speedCommand implements  ICommand{
        Receiver receiver=new Receiver();
        @Override
        public void cmd(){
            receiver.speed();
        }
    }
    static class pauseCommand implements  ICommand{
        Receiver receiver=new Receiver();
        @Override
        public void cmd(){
            receiver.pause();
        }
    }
    static class stopCommand implements  ICommand{
        Receiver receiver=new Receiver();
        @Override
        public void cmd(){
            receiver.stop();
        }
    }
    static  class Controller{
        private List<ICommand> list=new ArrayList<>();

        public void add(ICommand iCommand){
            list.add(iCommand);
        }
        public void clear(ICommand iCommand){
            list.clear();
        }
        public void execute(ICommand iCommand){
            iCommand.cmd();
        }
        public void executes(){
            for(ICommand iCommand:list){
                iCommand.cmd();
            }
        }
    }

    public static void main(String[] args) {
     //绑定receiver   
        //执行单条命令
        Controller controller=new Controller();
        controller.execute(new addCommand());
        //执行多条命令
        controller.add(new addCommand());
        controller.add(new speedCommand());
        controller.add(new stopCommand());
        controller.add(new stopCommand());
        controller.executes();
    }
}
```

上面的写法是在具体命令内部在编译的时候就直接绑定了receiver，这个不好，我们为了更优秀的拓展性，应该不是在构造命令的时候默认，而是应该将receiver作为构造方法参数传入，像下面这样：

```java
public class Client3 {
    interface   ICommand{
        void cmd();
    }
    static  class Receiver {
        public void add(){
            System.out.println("add");
        }
        public void speed(){
            System.out.println("speed");}
        public void stop(){
            System.out.println("stop");
        }
        public void pause(){
            System.out.println("pause");
        }
    }
    static class addCommand implements ICommand {
       Receiver receiver;
        public addCommand(Receiver receiver){
            this.receiver=receiver;
        }
        @Override
        public void cmd(){
            receiver.add();
        }
    }
    static class speedCommand implements ICommand {
        Receiver receiver;
        public speedCommand(Receiver receiver){
            this.receiver=receiver;
        }
        @Override
        public void cmd(){
            receiver.speed();
        }
    }
    static class pauseCommand implements ICommand {
        Receiver receiver;
        public pauseCommand(Receiver receiver){
            this.receiver=receiver;
        }
        @Override
        public void cmd(){
            receiver.pause();
        }
    }
    static class stopCommand implements ICommand {
        Receiver receiver;
        public stopCommand(Receiver receiver){
            this.receiver=receiver;
        }
        @Override
        public void cmd(){
            receiver.stop();
        }
    }
    static  class Controller{
        private List<ICommand> list=new ArrayList<>();

        public void add(ICommand iCommand){
            list.add(iCommand);
        }
        public void clear(ICommand iCommand){
            list.clear();
        }
        public void execute(ICommand iCommand){
            iCommand.cmd();
        }
        public void executes(){
            for(ICommand iCommand:list){
                iCommand.cmd();
            }
        }
    }

    public static void main(String[] args) {
        //未直接绑定receiver
        //执行单条命令
        Receiver receiver=new Receiver();
        Controller controller=new Controller();
      controller.execute(new speedCommand(receiver));
        //执行多条命令
        controller.add(new addCommand(receiver));
        controller.add(new speedCommand(receiver));
        controller.add(new stopCommand(receiver));
        controller.add(new stopCommand(receiver));
        controller.executes();
    }
}
```

### `状态模式`

允许对象在内部状态发生改变时改变它的行为，看起来好想修改了它的类，属于行为型设计模式。

也就是说状态模式中类的行为是由状态决定的，在不同的状态下又不同的行为。其意图是让一个对象在其内部改变的时候，行为也随之改变。状态模式的核心是状态和行为绑定，不同的状态对应不同的行为。

#### 作用

控制一个对象状态的条件表达式过于复杂时的情况，通过把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。

#### 应用场景

1. 行为与状态绑定
2. if else 逻辑过于复杂

#### 角色

环境类角色，内部维护状态接口实例，和一个设置状态的方法，用来切换状态信息。

抽象状态角色，定义该状态下的行为

具体状态角色，具体实现对应状态的对应行为

#### 补充知识

构造块会在创建对象时被调用，每次创建时都会被调用，优先于类构造函数执行。

```java
{

}
```

用static{}包裹起来的代码片段，只会执行一次。静态代码块优先于构造块执行。

```java
public class Person{

   static {
       System.out.println("静态代码块");
   }
}
```

静态代码块和构造代码块的异同点
1. 相同点： 都是JVM加载类后且在构造函数执行之前执行，在类中可定义多个，**一般在代码块中对一些static变量进行赋值。**

2. 不同点： 静态代码块在非静态代码块之前执行。静态代码块只在第一次new时执行一次，之后不在执行。而非静态代码块每new一次就执行一次。


#### 代码

```
package action.state;

/**
 * @Author weiwo
 * @Created on 2021/9/8
 */
public class Client {


    interface Istate{
       void  handle();
    }
    static  class State1 implements Istate{

        @Override
        public void handle() {
            System.out.println("state1");
        }
    }
    static  class State2 implements Istate{

        @Override
        public void handle() {
            System.out.println("state2");
        }
    }
    static  class State3 implements Istate{

        @Override
        public void handle() {
            System.out.println("state3");
        }
    }
    static class Context{
        Istate istate=new State1();

        public void setIstate(Istate istate){
            this.istate=istate;
        }
        public void handle(){
            this.istate.handle();
        }
    }

    public static void main(String[] args) {
        Context context = new Context();
        context.setIstate(new State3());
        context.handle();
        context.setIstate(new State2());
        context.handle();
    }
}
```

```
package action.state;

/**
 * @Author weiwo
 * @Created on 2021/9/8
 */
public class Client2 {
    static   int value=0;
    static abstract  class IState{
        protected Context context;

        public void setContext(Context context){
            this.context=context;
        }
        public abstract void handle();
    }
    static class State1 extends IState{
        @Override
        public void handle(){
            System.out.println("state1");
            //切换状态
         this.context.setState(Context.STATE2);
         this.context.getState().handle();

        }
    }
    static class State2 extends IState{
        @Override
        public void handle(){
            System.out.println("state2");
            this.context.setState(Context.STATE1);
            value++;
            System.out.println(value);
            if(value==3000){
                return;
            }
            this.context.getState().handle();


        }
    }
    static class Context{
   //context上下文中维护状态常量
        private static final IState STATE1=new State1();
        private static final IState STATE2=new State2();


       //语句块，在构造函数之前执行,一般用于对静态属性进行复制,每次new对象都会执行
       {
           STATE1.setContext(this);
           STATE2.setContext(this);
       }
        private IState iState;

        public void  setState(IState iState){
            this.iState=iState;
        }

        public void handle(){
            this.iState.handle();
        }

        public IState getState(){
            return this.iState;
        }
    }

    public static void main(String[] args) {
        Context context = new Context();
        context.setState(Context.STATE1);
        context.handle();
    }
}
```

### `备忘录模式`

又叫快照模式，或者是令牌模式（Token Pattern）

指在不破坏封装的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将对象恢复到原先保存的状态，属于行为型设计模式。

在软件系统中，备忘录模式提供一种后悔药的机制，它通过存储系统各个历史状态的快照，使得在任意时刻都可以将系统回滚到某一个历史状态。

>内部类的特点
>
>1. 内部类可以访问器所在类的属性，包括所在类的私有属性，内部类创建自身对象需要先创建其所在类的对象。
>
>```java
>public class TestInner {
>    private  int number=20;
>    public class Inner{
>        private  int number =200;
>        public void paint(){
>          int  number=400;
>            System.out.println(number);
>            System.out.println(this.number);
>            System.out.println(TestInner.this.number);
>        }
>    }
>
>    public static void main(String[] args) {
>        TestInner inner=new TestInner();
>        TestInner.Inner in=inner.new Inner();
>        System.out.println(in.number);
>
>        in.paint();
>        
>     XX // TestInner.Inner inner1=new TestInner.Inner();
>    }
>}
>```
>
>2. 一旦一个内部类使用static修饰，那么这个内部类就升级为顶级类，也就是说，出了写在一个类的内部意外，static内部类具备所有外部类的特性,举个例子，一个非静态的内部类不可以直接创建，需要先创建外部类，但是申明为静态之后就可以了
>
>```java
>  TestInner.Inner inner1=new TestInner.Inner();
>```
>
>但是之前创建内部类的方式就不行了。
>
>```java
>TestInner.Inner in=inner.new Inner(); XX
>```

#### 角色

发起人

备忘录（发起人的私有静态内部类）

空接口（被备忘录实现）

调用者（备忘录管理员）

或者

发起人（可以自身state为参数，创建备忘录）

备忘录 （存储发起人的内部状态）

调用者（内部维护备忘录实例，作用是存储和获取）

```java
public class Client {

    public static void main(String[] args) {
     Originator originator=new Originator();
     originator.setState("state1");
        Originator.Memory memory = originator.createMemory();
      MemoryManer memoryManer=new MemoryManer();
      memoryManer.setMemory(memory);

      originator.setState("state2");
      originator.restore(memory);
        System.out.println(originator.getState());

        //快照管理者可以修改。查看内容嘛
    }

    static  class MemoryManer{
        private IMemory iMemory;

        public IMemory getMemory() {
            return iMemory;
        }

        public void setMemory(IMemory iMemory) {
        this.iMemory=iMemory;
        }
    }
    interface  IMemory{}
    static  class Originator{
        private String state;
        public String getState() {
            return state;
        }
        public void setState(String state){
            this.state= state;
        }
        //创建一个备忘录
        public Memory createMemory(){
            return new Memory(this.state);
        }

        //恢复状态 需要传参数备忘录 memory
        public void restore(IMemory iMemory){
          this.state=((Memory)iMemory).state;
        }

       private static class Memory implements  IMemory{

            private String state;
            public Memory(String state){
                this.state=state;
            }

        }
    }
}
```

#### 优点

提供状态存储与获取，可以回滚

#### 缺点

存储状态到外部，多占用内存。
