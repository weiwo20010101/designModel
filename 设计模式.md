## 设计模式 

### 创建型设计模式

### 代码

[github链接](https://github.com/weiwo20010101/designModel)

### `简单工厂模式`

#### 定义

简单工厂模式有一个具体的工厂类，在产品种类相对较小的情况下，考虑使用简单工厂模式可以很方便的创建所需产品。

#### 角色

简单工厂 抽象产品 具体产品

#### **简单工厂模式在框架源码中的应用**

- 在 `Logback`源码中的应用

  ```java
  public class JDKCalendar {
    
      private static final Logger log= LoggerFactory.getLogger(JDKCalendar.class);
  
  }
  
      public static Logger getLogger(Class<?> clazz) {
          return new Logger(clazz.getName());
      }
  
  
      public Logger(String name) {
          impl = java.util.logging.Logger.getLogger(name);
      }
  
  ```

#### **简单工厂模式的优点**

结构简单，调用方便，对于外界给定的信息，我们能够很方便的创建出对应的产品。

#### **简单工厂模式的缺点**

工厂类单一，当产品技术过多，工厂类代码十方臃肿，考虑进一步的划分。

### `工厂方法模式`

#### 介绍

指定义一个创建对象的接口，但是由实现这个接口的类来决定实例化哪个类，工厂方法把类的实例化推迟到子类中进行。

当增加一个产品时，只需增加一个相应的工厂类的子类，实现生成这种产品，便可解决简单工厂生产太多产品导致其内部代码臃肿的问题，符合开闭原则（增加类，而不是修改之前的代码）。

#### 角色

- 抽象工厂

- 具体工厂

- 抽象产品

- 具体产品

#### **使用工厂方法模式实现产品拓展**

工厂方法模式主要解决产品拓展的问题，在简单工厂中，随着产品链的丰富，如果每个课程的创建逻辑都有区别，则工厂的职责会变得越来越多，有点像万能工厂，不符合单一职责原则，不利于维护，于是我们继续拆分，专人干专事，Java课程由Java工厂创建，Python课程由Python工厂创建，对工厂本身也做抽。

#### **在`Logback`源码中的应用**

#### **缺点**

类的个数过多，增加复杂度

抽象产品只能生产一种产品

增加了系统的抽象性和理解难度

### `抽象工厂模式`

#### **介绍**

抽象工厂模式指提供一个创建一系列相关或者相互依赖对象的接口，无需指定他们具体的类。

在抽象工厂模式中，客户端强调一系列相关的产品对象（同一个产品族）一起创建，需要大量重复的代码。

需要一个提供产品类的库，所有产品以同样的接口出现，一种产品一个接口，抽象工厂返回的是所有的抽象接口。

抽象工厂也可以使用`abstract`+`extends`的方式具体化。

#### **概念**

产品族  一家工厂提供的所有产品  假设 m种

产品等级结构   不同工厂提供的同一种产品   假设 n种

产品    由产品族和产品等级结构划分   m*n种  需要大量重复的代码

### `单例模式`

#### **定义**

确保一个类在任何情况下都绝对都只有一个实例，并且提供一个全局访问点，属于创建型设计模式。

#### **应用场景**

- 对于一些频繁创建的类，减少内存压力，减少GC
- 某些类创建实例时占用资源较多，或者实例化耗时较长，且经常使用
- 频繁访问数据库和文件的对象

#### **实现方式**

通过隐藏构造方法，在内部实例化一次，并且提供一个全局的访问点。

#### **使用单例模式解决实际问题**

#####     饿汉式 单例写法的弊端

饿汉式单例模式的标准写法

```java
public class Client {
    public static void main(String[] args) {
        Singleton instance = Singleton.getInstance();

    }

    static class Singleton{
        private static  final  Singleton instance=new Singleton();
        private Singleton(){};
        public static Singleton getInstance(){
            return instance;
        }
    }
}
```

饿汉式单例写法在类的加载的时候立即进行初始化，并且创建单例对象。在线程还没出现之前就实例化了，不可能存在访问安全问题。

饿汉式的另外一种写法，使用静态块的机制。

```java
public class Client2 {

    static  class HungryStaticsSingleton{
        private static final  HungryStaticsSingleton hungrySingleton;
        static {
            hungrySingleton=new HungryStaticsSingleton();
        }
        private  HungryStaticsSingleton(){};
        public  static  HungryStaticsSingleton getInstance(){
            return hungrySingleton;
        }
    }
}
```

饿汉式单例写法适用于单例对象较少的情况。这样写可以保证绝对的线程安全（在类加载的时候就进行初始化，并且创建单例对象）,但是缺点也比较明显，就是所有对象累在类加载的时候就实例化。这样一来，如果系统中有大批量的单例对象存在，那么初始化时会造成大量的内存浪费，从而导致系统内存不可控。也就是说，不管对象用或者不用，都占着空间，浪费了内存，有可能占着内存又不使用，那么这个时候有没有更优的写法呢？

##### 懒汉式写法

在使用的时候才会初始化

```java
public class Client3 {
     
    static  class  Singleton{
        private Singleton(){};
        
        private static Singleton instance=null;
        public static  Singleton getInstance(){
          if(instance==null){
              instance=new Singleton();
          }
          return instance;
        }
    }
}

```

但是这样写又带来了一个新的问题，如果在多线程环境下，则会出现线程安全问题，存在线程安全隐患。

这里我简单的使用同步方法解决，加锁对性能有一定的影响。

```
public class Client4 {

    static  class  Singleton{
        private Singleton(){};
        private  static  Singleton singleton=null;

        public  static synchronized  Singleton getInstance(){
            if(singleton==null){
                singleton=new Singleton();
            }
            return singleton;
        }
    }
}
```

### `原型模式`

#### 定义

原型模式 指原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象，属于创建型设计模式。

原型模式的核心在于复制原型对象。以系统中已经存在的一个对象为原型，直接基于内存二进制流进行复制，不需要再经历耗时的对象初始化过程
