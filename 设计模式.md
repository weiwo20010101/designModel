## 设计模式 

### 创建型设计模式

### 代码

[github链接](https://github.com/weiwo20010101/designModel)

### `简单工厂模式`

#### 定义

简单工厂模式有一个具体的工厂类，在产品种类相对较小的情况下，考虑使用简单工厂模式可以很方便的创建所需产品。

#### 角色

简单工厂 抽象产品 具体产品

#### **简单工厂模式在框架源码中的应用**

- 在 `Logback`源码中的应用

  ```java
  public class JDKCalendar {
    
      private static final Logger log= LoggerFactory.getLogger(JDKCalendar.class);
  
  }
  
      public static Logger getLogger(Class<?> clazz) {
          return new Logger(clazz.getName());
      }
  
  
      public Logger(String name) {
          impl = java.util.logging.Logger.getLogger(name);
      }
  
  ```

#### **简单工厂模式的优点**

结构简单，调用方便，对于外界给定的信息，我们能够很方便的创建出对应的产品。

#### **简单工厂模式的缺点**

工厂类单一，当产品技术过多，工厂类代码十方臃肿，考虑进一步的划分。

### `工厂方法模式`

#### 介绍

指定义一个创建对象的接口，但是由实现这个接口的类来决定实例化哪个类，工厂方法把类的实例化推迟到子类中进行。

当增加一个产品时，只需增加一个相应的工厂类的子类，实现生成这种产品，便可解决简单工厂生产太多产品导致其内部代码臃肿的问题，符合开闭原则（增加类，而不是修改之前的代码）。

#### 角色

- 抽象工厂

- 具体工厂

- 抽象产品

- 具体产品

#### **使用工厂方法模式实现产品拓展**

工厂方法模式主要解决产品拓展的问题，在简单工厂中，随着产品链的丰富，如果每个课程的创建逻辑都有区别，则工厂的职责会变得越来越多，有点像万能工厂，不符合单一职责原则，不利于维护，于是我们继续拆分，专人干专事，Java课程由Java工厂创建，Python课程由Python工厂创建，对工厂本身也做抽。

#### **在`Logback`源码中的应用**

#### **缺点**

类的个数过多，增加复杂度

抽象产品只能生产一种产品

增加了系统的抽象性和理解难度

### `抽象工厂模式`

#### **介绍**

抽象工厂模式指提供一个创建一系列相关或者相互依赖对象的接口，无需指定他们具体的类。

在抽象工厂模式中，客户端强调一系列相关的产品对象（同一个产品族）一起创建，需要大量重复的代码。

需要一个提供产品类的库，所有产品以同样的接口出现，一种产品一个接口，抽象工厂返回的是所有的抽象接口。

抽象工厂也可以使用`abstract`+`extends`的方式具体化。

#### **概念**

产品族  一家工厂提供的所有产品  假设 m种

产品等级结构   不同工厂提供的同一种产品   假设 n种

产品    由产品族和产品等级结构划分   m*n种  需要大量重复的代码

### `单例模式`

#### **定义**

确保一个类在任何情况下都绝对都只有一个实例，并且提供一个全局访问点，属于创建型设计模式。

#### **应用场景**

- 对于一些频繁创建的类，减少内存压力，减少GC
- 某些类创建实例时占用资源较多，或者实例化耗时较长，且经常使用
- 频繁访问数据库和文件的对象

#### **实现方式**

通过隐藏构造方法，在内部实例化一次，并且提供一个全局的访问点。

#### **使用单例模式解决实际问题**

#####     饿汉式 单例写法的弊端

饿汉式单例模式的标准写法

```java
public class Client {
    public static void main(String[] args) {
        Singleton instance = Singleton.getInstance();

    }

    static class Singleton{
        private static  final  Singleton instance=new Singleton();
        private Singleton(){};
        public static Singleton getInstance(){
            return instance;
        }
    }
}
```

饿汉式单例写法在类的加载的时候立即进行初始化，并且创建单例对象。在线程还没出现之前就实例化了，不可能存在访问安全问题。

饿汉式的另外一种写法，使用静态块的机制。

```java
public class Client2 {

    static  class HungryStaticsSingleton{
        private static final  HungryStaticsSingleton hungrySingleton;
        static {
            hungrySingleton=new HungryStaticsSingleton();
        }
        private  HungryStaticsSingleton(){};
        public  static  HungryStaticsSingleton getInstance(){
            return hungrySingleton;
        }
    }
}
```

饿汉式单例写法适用于单例对象较少的情况。这样写可以保证绝对的线程安全（在类加载的时候就进行初始化，并且创建单例对象）,但是缺点也比较明显，就是所有对象累在类加载的时候就实例化。这样一来，如果系统中有大批量的单例对象存在，那么初始化时会造成大量的内存浪费，从而导致系统内存不可控。也就是说，不管对象用或者不用，都占着空间，浪费了内存，有可能占着内存又不使用，那么这个时候有没有更优的写法呢？

##### 懒汉式写法

在使用的时候才会初始化

```java
public class Client3 {
     
    static  class  Singleton{
        private Singleton(){};
        
        private static Singleton instance=null;
        public static  Singleton getInstance(){
          if(instance==null){
              instance=new Singleton();
          }
          return instance;
        }
    }
}

```

但是这样写又带来了一个新的问题，如果在多线程环境下，则会出现线程安全问题，存在线程安全隐患。

这里我简单的使用同步方法解决，加锁对性能有一定的影响。

```
public class Client4 {

    static  class  Singleton{
        private Singleton(){};
        private  static  Singleton singleton=null;

        public  static synchronized  Singleton getInstance(){
            if(singleton==null){
                singleton=new Singleton();
            }
            return singleton;
        }
    }
}
```

### `原型模式`

#### 定义

不是通过`new`关键字而是通过对象复制来实现创建对象的模式被称为原型模式。

原型模式 指原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象，属于创建型设计模式。

原型模式的核心在于复制原型对象。以系统中已经存在的一个对象为原型，直接基于内存二进制流进行复制，不需要再经历耗时的对象初始化过程（不调用构造函数），性能提升很多。

这为我们创建对象另辟蹊径，当对象的构建过程比较耗时的时候，我们可以躲避初始化过程，使得新对象的创建时间大大缩短。

#### 应用场景

1. 创建对象成本较大 （例如：初始化时间长渣，占用CPU多，占用网络资源太多）
2. 创建一个对象需要繁琐的数据准备和访问权限等等，需要提高性能和提高安全性。
3. 该对象在系统中大量使用，并且各个调用者都需要给它的属性重新赋值。

#### 角色

1. 客户`client` ：客户提出创建对象的请求
2. 抽象原型 `IPrototype`：规定复制接口
3. 具体原型 `ConcretePrototype`：被复制的对象

#### 使用原型模式解决实际问题

在Java提供的API中，不需要手动创建抽象原型接口，因为Java已经内置了`Cloneable` 抽象原型接口，自定义的类型只需要实现该接口并且重写`Object.clone()`即可完成本类的复制。

实现该接口唯一的意思是告知Java虚拟机可以安全的在本类中使用clone()方法，而如果没有实现该接口，调用clone()就会抛出 `CloneNotSupportedException`异常。

复制的结果有如下性质：

1.  `o.clone() != o`
2.  ` o.clone().getClass() =  o.getClass()`
3.  `o.clone().equals(o)`  如果对象o的`equals()`方法定义正确

```java
public class Client2 {


    public static void main(String[] args) {
        Prototype prototype=new Prototype("origin");
        Prototype clone = prototype.clone();
        System.out.println(clone.toString());
    }
    static class Prototype implements Cloneable{
        private  String desc;

        public Prototype(String desc){
            this.desc=desc;
        }
        @Override
        public Prototype clone(){
            Prototype prototype=null;
            try{
                prototype=(Prototype) super.clone();
            } catch (CloneNotSupportedException e) {
                e.printStackTrace();
            }
            return prototype;
        }

        @Override
        public String toString(){
            return this.getClass().getSimpleName() +".desc= "+desc;
        }
    }
}
```

`super.clone()`方法直接从堆内存中以二进制流的方式进行复制，重新分配一个内存块，因此效率很高滴。

也就是说该方法基于内存复制，不会调用对象的构造方法，也就是Java字节码层面的` <init>`方法，不需要经历初始化过程。

#### 存在的问题

##### 问题1

在日常开发中，使用`super.clone()`方法并不能满足所有需求，如果类中存在引用对象属性，那么原型对象与克隆对象的该属性会指向同一对象的应用。例如属性`List<String> strs`,这显然不是我们想要的结果，那么如何解决呢？

序列化

##### 解决方法

使用序列化实现深克隆

我对输入输出流的了解有限，现在了解一下`ByteArrayOutputStream`,`ObjectOutputStream`...........


对象操作流 `ObjectOutputStream` `ObjectInputStream`

```java
 
public class Demo1_ObjectOutputStream {
 
	public static void main(String[] args) throws IOException{
		Student s1=new Student("张三",23);
		Student s2=new Student("李四",24);
		ObjectOutputStream os=new ObjectOutputStream(new FileOutputStream("record.txt"));
		os.writeObject(s1);
		os.writeObject(s2);
		os.close();

	} 
}

public class Demo2_ObjectInputStream {
 
	public static void main(String[] args) throws IOException, ClassNotFoundException {
		ObjectInputStream ois=new ObjectInputStream(new FileInputStream("record.txt"));
		Student s1=(Student) ois.readObject();
		Student s2=(Student) ois.readObject();
		System.out.println(s1);
		System.out.println(s2);
		ois.close();
 
	}
 
}


public class Demo3 {
 
	public static void main(String[] args) throws IOException, ClassNotFoundException {
		ArrayList<Student> list1=new ArrayList<Student>();
		list1.add(new Student("张三",23));
		list1.add(new Student("李四",24));
		list1.add(new Student("王五",25));
		list1.add(new Student("赵六",26));
		ObjectOutputStream os=new ObjectOutputStream(new FileOutputStream("record.txt"));
		os.writeObject(list1);
		System.out.println("集合对象写入到文件成功！");
		os.close();
		ObjectInputStream osi=new ObjectInputStream(new FileInputStream("record.txt"));
		ArrayList<Student> list2=(ArrayList<Student>) osi.readObject();
		osi.close();
		System.out.println("从磁盘读取到的集合遍历结果");
		for (Student student : list2) {
			System.out.println(student);
		}
	}
}
```

深复制的实现

```java
public class Client3{


    static class Prototype implements Cloneable{
        private  String desc;

        public Prototype(String desc){
            this.desc=desc;
        }

        @Override
        public Prototype clone(){
            Prototype prototype=null;
            try{
                prototype=(Prototype) super.clone();
            } catch (CloneNotSupportedException e) {
                e.printStackTrace();
            }
            return prototype;
        }

        @Override
        public String toString(){
            return this.getClass().getSimpleName() +".desc= "+desc;
        }

        public Prototype deepClone(){
            try {
                ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
                ObjectOutputStream objectOutputStream=new ObjectOutputStream(outputStream);
                objectOutputStream.writeObject(this);

                ObjectInputStream objectInputStream=new ObjectInputStream(new ByteArrayInputStream(outputStream.toByteArray()));
                Object o = objectInputStream.readObject();
                return (Prototype) o;
            }catch (IOException | ClassNotFoundException e){
                e.printStackTrace();
                return  null;
            }
        }
    }
}
```

##### 问题2

破坏了克隆怎么办？

##### 解决方法

- 单例类不实现 `cloneable` 接口，自然就不可以克隆了，不然会抛出异常

- 重写clone()方法，返回单例对象即可。

  ```java
  @Override
  pubilc Prototype clone(){
      return instance;
  }
  ```

#### 原型模式的优点

- 基于内存二进制流的方式，在性能上比直接new更加的优良。
- 深克隆的方式可以做到完全复制，有助于保存对象的状态，简化创建对象的过程，也可以用来还原到某一个历史状态，可辅助实现撤销操作。

#### 原型模式的缺点

- 需要为类配置一个`clone()`方法

- `clone()`位于类的内部，对方法改造的话，不符合开闭原则。

- 实现深克隆的话，需要进行序列化和反序列化，操作很复杂

### `建造者模式`

属于创建型设计模式，将一个复杂对象的构建过程与表示分离，实现构建与表示分离，使得同样的构建行为根据不同的过程来创建不同的表示，其中构建的行为顺序有时候也会导致不同的表示。

#### 应用场景 

创建简单而又多类的对象，使用工厂模式，而如果是创建一个复杂的对象，就可以考虑使用建造者模式。

需求：

相同的方法，不同的执行顺序，产生不同的结果。

多个部件或零件，都可以装配到一个对象中，但是产生的结果不同。

初始化一个复杂对象的很多参数都具有默认值。

#### 角色

1. 产品

2. 抽象建造者：建造者的抽象类，规范产品对象的各个组成部分的创建，一般由子类实现具体的创建过程。

3. 建造者 ：具体的`Builder`类，根据不同的业务逻辑，具体化对象的各个组成部分的创建

4. 调用者：调用具体的建造者来创建对象的各个组成部分，在指导者中不涉及具体产品的信息，只负责保证对象个部分完整创建或者按照某个顺序创建。

   

#### 拓展

建造者模式的优点

1. 封装好，构建和表示分离
2. 拓展性好，构建类之间独立，在一定程度上解耦。
3. 便于控制细节，建造者可以对创建过程逐步细化，而不对其他模块产生影响

建造者模式的缺点

1. 多创建一个`builder`

2. 如果产品内部发生变化，建造者也要发生变化，后期维护困难。

### 结构型模式

### `代理模式`

代理模式是指为其他对象提供一种代理，以控制对这个对象的访问，数据结构型设计模式。

代理对象可以在客户端与目标对象之间起到中介的作用。

#### 应用场景

当无法或者不想直接引用某个对象或者访问某个对象存在困难的时候，可以通过代理对象来间接访问，使用代理模式主要有两个目的，一是保护目标对象，二是增强目标对象。

#### 角色

抽象主题角色：声明真实主题与代理的共同接口方法，该类可以是接口，也可以是抽象类。

真实主题角色：

代理主题角色：也被称为代理类，其内部持有真实主题角色的应用，具备对真实主题角色的完全代理权。

客户端调用代理对象的方法，也调用被代理对象的方法，代码增强体现在在原代码逻辑前后增加一些代码逻辑，而使得调用者无感知。

#### 分类

静态代理

动态代理

#### 使用代理模式解决实际问题

比如从静态代理到动态代理。

从一对父母帮自己孩子说媒到开办婚介所。

#### Java动态代理

```java
public class Client2 {
    public static void main(String[] args) {
        JdkMeipo meipo=new JdkMeipo();
        IPerson instance = meipo.getInstance(new ZhaoLiu());
        instance.findLove();
    }
    interface IPerson{
        void findLove();
    }

    static class  JdkMeipo implements InvocationHandler{

        private IPerson target;
        public IPerson getInstance(IPerson target){
            this.target=target;
            Class<? extends IPerson> clazz = target.getClass();
            return (IPerson) Proxy.newProxyInstance(clazz.getClassLoader(),clazz.getInterfaces(),this);
        }
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            String name=method.getName();
            Object result=null;
            before();
            if(name.equals("findLove")){

                 result= method.invoke(this.target,args);
                 System.out.println("是这个");
            }
            after();
            return  result;
        }
        public void before(){
            System.out.println("媒婆收到需求，开始物色");
        }
        public void after(){
            System.out.println("多才多亿 开始交往");
        }
    }
    static class ZhaoLiu implements IPerson{
        @Override
        public void findLove(){
            System.out.println("符合老刘的要求");
        }
        public void buyInsure(){

        }
    }
}
```

![image-20210906010459872](https://gitee.com/weiwo20010101/image/raw/master/image-20210906010459872.png)

#### 结合源码分析

暂无

#### 总结

静态代理违背开闭原则，如果被代理类增加了新的方法，则代理类需要同步增加

动态代理具有可拓展性，符合开闭原则。

动态代理可配合策略模式使用，新增策略类即可完成拓展，无需修改代理类的代码。

#### 优点

将代理对象与真实对象分离

降低耦合性，拓展性好

保护或增强目标对象

#### 缺点

类数量，处理请求速度 ，系统复杂度。

### `门面模式`

又叫外观模式，提供了一个统一的接口，用来访问子系统中的一群接口，其主要特征是定义了一个高层接口，让子系统更容易调用，属于结构型设计模式。

#### 使用门面模式整合已知API

比如某个社区上线了一个积分兑换礼品的商城，这个商城中的大部分功能都不是重新开发的，而是要去对象已有的各个子系统。

如果所有的接口调用全部去由前端发送网络请求去调用一直接口，一会增加前端开发人员的难度，二会增加一些网络请求，影响网络性能，此时就可以发挥门面模式的优势了。将所有线程的接口全部整合到一个类中，由后端提供统一的接口供前端调用，这样前端开发人员就可以不需要关心各个接口的业务关系，只需要把经历集中到页面交互上去。

#### 源码应用

- Spring JDBC 模块下的JdbcUtils类，他们封装了与JDBC有关的所有操作。

#### 总结

门面模式的优点

- 方便调用
- 不用深入了解子系统，以防给子系统带来风险
- 符合设计原则中的最少知道原则，和具体实现解耦，提高了安全性。

门面模式的缺点

- 一定程度上违背单一职责原则

- 不符合开闭原则，因为当子系统修改了，那么门面的调用也要跟着改。

  

### `装饰器模式`

装饰器模式也叫做包装模式，是指在不改变原有对象的基础上动态给一个对象增加一些额外的职责,比起生成子类实现更为灵活。

提起装饰，我们先来想一下生活中有哪些装饰：

提到装饰，我们先来想一下生活中有哪些装饰：

女生的首饰：戒指、耳环、项链等装饰品
家居装饰品：粘钩、镜子、壁画、盆栽等等
我们为什么需要这些装饰品呢？我们很容易想到是为了美，戒指、耳环、项链、壁画、盆栽都是为了提高颜值或增加美观度。但粘钩、镜子不一样，它们是为了方便我们挂东西、洗漱。所以我们可以总结出装饰品共有两种功能：

- 增强原有的特性：我们本身就是有一定颜值的，添加装饰品提高了我们的颜值。同样地，房屋本身就有一定的美观度，家居装饰提高了房屋的美观度。
- 添加新的特性：在墙上挂上粘钩，让墙壁有了挂东西的功能。在洗漱台装上镜子，让洗漱台有了照镜子的功能。

并且我们发现，装饰品并不会改变物品本身，只是起到一个锦上添花的作用。装饰模式也一样，它的主要作用就是：

- 增强一个类原有的功能
- 为一个类添加新的功能

并且装饰模式也不会改变原有的类。

模板  请画出UML图

```java
public class Client {

   static abstract class Component{
         abstract  void operation();
    }
    static  abstract  class Decorator extends Component{

        private Component component;
        public Decorator(Component component){
            this.component=component;
        }

        public void operation(){
           component.operation();
        }
    }
    static class ConcreteDecoratorA extends Decorator{
       public ConcreteDecoratorA(Component component){
           super(component);
       }
       public void after(){
           System.out.println("after");
       }
        public void before(){
            System.out.println("before");
        }

        @Override
        public void operation() {
            before();
            super.operation();
            after();
        }
    }
    static class ConcreteDecoratorB extends Decorator{
        public ConcreteDecoratorB(Component component){
            super(component);
        }
        public void after(){
            System.out.println("after");
        }
        public void before(){
            System.out.println("before");
        }

        @Override
        public void operation() {
            before();
            super.operation();
            after();
        }
    }
     static class ConcreteComponent extends Component{


         @Override
         void operation() {
             System.out.println("playing");
         }
     }
    public static void main(String[] args) {
        ConcreteComponent component=new ConcreteComponent();
        ConcreteDecoratorA concreteDecoratorA = new ConcreteDecoratorA(component);
        concreteDecoratorA.operation();

    }

}

```

学会使用装饰器模式解决`加码`问题。比如给煎饼多加一块肉，还是煎饼，但是价格和数量都会有所变化

![image-20210906181344758](https://gitee.com/weiwo20010101/image/raw/master/image-20210906181344758.png)

具体代码见`github`

#### 特征

实现接口的类型就是装饰器中属性元素的类型

```java
public class TransactionAwareCacheDecoretor implements Cache{
    private final Cache targetCache;8
    public TransactionAwareCacheDecoretor(Cache targetCache){
        this.targetCache=targetCache;
    }
}
```

具体装饰器继承抽象装饰器（一般是抽象类），实现抽象方法，共用父类属性，而父类属性是被装饰对象和抽象装饰器的共同接口，构造方法调用父类构造方法，同样的方法名，内部其实对父类方法进行一定修改。

抽象装饰器保存对共同接口的应用。

#### 区别

装饰器模式强调自身功能的拓展.`Decorator`所做的就是增强`Concrete Component`的功能，主体对象为`Concrete Component`,着重类功能的变化。

代理模式强调对代理过程的控制。`Proxy`完全掌握对`RealSubject`的访问控制，因此，`Proxy`可以决定对`RealSubject`进行功能拓展，功能缩减，主体对象是`Proxy`

拿租房来讲，必然有一些事务发生：比如房源搜索，联系房东谈价格。

- 中介去做

- 增加自己相关的能力，自己去做。

### `享元模式`

面向对象的技术可以很好的解决一些灵活性或者可拓展性问题，但在很多情况下需要在系统中增加类和对象的个数。当对象数量太多，将导致运行代价过高，带来性能下降问题。享元模式正式为了解决这一问题而诞生的。

其实就是缓存的思想。

#### 实现方式举例

- 使用hashmap实现缓存，有就获取，没有再创建

- 池化技术
- String类型

```
public class StringTest {
    public static void main(String[] args) {
   String s1="hello";
   String s2="he"+"llo";
   String s3=new String("hello");
   String s5="he"+new String("llo");
   String s6=s5.intern();
   String s7=s3.intern();
   String s8="h";
   String s9="ello";
   String s10=s8+s9;
        System.out.println(s1==s2);
        System.out.println(s1==s3);
        System.out.println(s1==s5);
        System.out.println(s1==s6);
        System.out.println(s1==s7);
        System.out.println(s1==s10);
        System.out.println(s5==s6);
        System.out.println(s6==s7);
        
        System.out.println(s6==s2);

    }
}

```

对这些比较的理解涉及到JVM的概念，我正好学过一遍，还是不难的：

String类型被定义为由final修饰的，是不可变的，JVM中字符串一般都被保存在字符串常量池，Java会确保一个字符串在常量池中只有一个"复制"，在JDK7之前，字符串常量池是放在方法区（也叫永久代）的常量池中的，之后被放置到堆中（因为我们在开发中需要创建大量并且一次性的字符串，需要较高的垃圾回收频率，而在永久代比起堆空间，垃圾回收是很少的）。

对于`new String("")`之类的方法，实际上是创建了一个对象在堆空间中，而不是一个到字符创常量池的引用，当然不是一个引用。并且对于字符串来说,`==`这种比较方式比较的是地址，而不是值，这也是我们分析所在区域的前提。

- 特殊的，`s5.intern()`这个方法是使得一个位于堆中的字符串在运行期间动态的加入字符串常量池，如果池中已经有了该对象对应的字面量，就返回引用，否则就复制一份字面量到字符串常量池中并且返回引用。
- 特殊的，对于s2的写法，JVM在编译期间是自动优化的，拼接起来。

Integer和Long类型的缓存:  -128~127

#### 享元模式的优点

减少对象创建降低内存

#### 享元模式的缺点

比较关注内，外部状态，内部是指共享出来的信息，外部随环境而改变，不可共享。

逻辑更复杂。

### `组合模式`

组合模式用于整体与部分的关系，当整体与部分有相似的接口，在操作的时候可以被一致地对待的时，就可以使用组合模式。

例如：树形菜单，公司组织架构和操作系统目录，文件夹和子文件夹的关系，文件夹中可以存放文件，也可以新建文件夹，子文件夹也一样，总公司和子公司的关系，公司可以设立部门，也可以设立分公司，分公司同理，树枝和分树枝的关系，树枝可以长出叶子，也可以长出树枝，分树枝也一样。

```java
public class Client {

     static abstract class Component {
        // 职位
        private String position;
        // 工作内容
        private String job;

        public Component(String position, String job) {
            this.position = position;
            this.job = job;
        }

        // 做自己的本职工作
        public void work() {
            System.out.println("我是" + position + "，我正在" + job);
        }

        abstract void addComponent(Component component);

        abstract void removeComponent(Component component);

        abstract void check();
    }
   static class Manager extends Component {
        // 管理的组件
        private List<Component> components = new ArrayList<>();

        public Manager(String position, String job) {
            super(position, job);
        }

        @Override
        public void addComponent(Component component) {
            components.add(component);
        }

        @Override
        void removeComponent(Component component) {
            components.remove(component);
        }

        // 检查下属
        @Override
        public void check() {
            work();
            for (Component component : components) {
                component.check();
            }
        }
    }
    static class Employee extends Component {

        public Employee(String position, String job) {
            super(position, job);
        }

        @Override
        void addComponent(Component component) {
            System.out.println("职员没有管理权限");
        }

        @Override
        void removeComponent(Component component) {
            System.out.println("职员没有管理权限");
        }

        @Override
        void check() {
            work();
        }
    }
}
```

使用组合模式之后，我们解决了之前的两个弊端。

将共有的字段和方法移到了父类中，消除了重复，并且在客户端中，可以一致地对待`Manager`和`Employee`类，因为统一申明为`Component`对象，统一调用`Component`对象的`addComponent`方法添加子对象即可。

#### 透明方式

我们应该注意到，`Employee`类虽然继承了父类的`addComponent`和`removeComponent`方法，但是仅仅提供了一个空实现罢了，因为`Employee`类是不支持添加和移除组件的。这样是否违背了接口隔离原则呢?

>接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。

答案是肯定的，这样却是违背了接口隔离原则。这种方式在组合模式中被称为透明方式。

这种方式有它的优点：让 Manager 类和 Employee 类具备完全一致的行为接口，调用者可以一致对待它们。

但它的缺点也显而易见：Employee 类并不支持管理子对象，不仅违背了接口隔离原则，而且客户端可以用 Employee 类调用 addComponent 和 removeComponent 方法，导致程序出错，所以这种方式是不安全的。

#### 安全方式

那么我们可不可以将 addComponent 和 removeComponent 方法移到 Manager 子类中去单独实现，让 Employee 不再实现这两个方法呢？我们来尝试一下。

```java
public class Client2 {

    static abstract class Component{
        private String position;
        private String job;
        public Component(String position,String job){
            this.job=job;
            this.position=position;
        }
        public void work(){
            System.out.println("我是"+position+"我正在"+job);
        }
        abstract  void check();
    }
    static class Manager extends Component{
        private List<Component> list =new ArrayList<>();

        public Manager(String position, String job) {
            super(position, job);
        }

        @Override
        public void work() {
          super.work();
        }

        @Override
        void check() {
             work();
             for(Component component:list){
                 component.check();
             }
        }
        public void addComponent(Component component){
            list.add(component);
        }
        public void removeComponent(Component component){
            list.remove(component);
        }

    }
    static class Employee extends Component{
        public Employee(String position, String job) {
            super(position, job);
        }

        @Override
        public void work() {
            super.work();
        }

        @Override
        void check() {
       work();
        }
    }

    public static void main(String[] args) {
      Employee employee=new Employee("c","d");
      Manager manager=new Manager("a","b");
      manager.addComponent(employee);
      manager.check();
    }
}
```

安全方式符合接口隔离原则，上层接口或者抽象类选择交集。

同样的，由于将两个类区别对待，两个类具有不同的接口，带来了使用上的不变。

#### 组合模式

一般是使用透明方法，虽然优点不安全，但是客户端不需要去区分叶子节点和枝节点，用起来真香。

问：组合模式中的安全方式与透明方式有什么区别？

答案：声明内容是节点方法的  交集 还是 并集

透明方式：在 Component 中声明**所有**管理子对象的方法，包括 add 、remove 等，这样继承自 Component 的子类都具备了 add、remove 方法。对于外界来说叶节点和枝节点是透明的，它们具备完全一致的接口。

安全方式：在 Component 中不声明 add 和 remove 等管理子对象的方法，这样叶节点就无需实现它，只需在枝节点中实现管理子对象的方法即可。

